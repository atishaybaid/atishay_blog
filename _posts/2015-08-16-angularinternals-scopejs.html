---
layout: post
title: angularInternals-Scope.js
date: '2015-08-16T01:35:00.000-07:00'
author: atishay
tags: 
modified_time: '2015-08-16T01:35:45.699-07:00'
blogger_id: tag:blogger.com,1999:blog-5476905830108124987.post-5096666068347038787
blogger_orig_url: http://www.atishaybaid.com/2015/08/angularinternals-scopejs.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on">Scope.js is a mini framework for implementing angular scope objects<br />I build this framework for having a deeper understanding of &nbsp;data-binding and dirty checking principle of angularjs.<br /><br />&nbsp;The framework implements these four main areas of functionality:<br />&nbsp;1)Scope inheritance-&gt;creating scope hierarchies for sharing data and events<br />&nbsp;2)Dirty checking-&gt;checking for changes in data and calling the appropriate listeners.<br />&nbsp;3)Evaluating functions-&gt;Evaluating the functions with the current scope.<br />&nbsp;4)Destroying watches-&gt;Ability to destroy active watches.<br /><br />&nbsp;<b>How is it build?</b><br />The framework is &nbsp;implemented using plain JavaScript,using no external libraries.<br />&nbsp;It is developed in a TDD environment,using jasmine-karma for writing and executing test cases.<br /><br /><b>Implementation</b><br />I followed a TDD approach to implement the framework.For every functionality we will write a failing tests and then we will trying passing these tests by creating the &nbsp;functionality.<br /><br />To begin with a &nbsp; constructor function was created,and was &nbsp;used to create instances for other objects.<br /><br /><script src="https://gist.github.com/atishaybaid/3cfd9d0d3f7e6dc49953.js"></script> <br /><br />Angular scopes are plain JavaScript objects,there is nothing special about them.The real magic of &nbsp;dirty-checking happens in $watch() function,</div>We pass a watcher function and a listener function to $watch.As every scope can have a number of watches,so we store them in the form of a array($$watchers) in the Scope object.<br /><br /><script src="https://gist.github.com/atishaybaid/4c46ca43539b42836f38.js"></script> <br /><br />Finally there is $digest(),which iterates through all the watches,and calls there cosponsoring listeners if the value is updated.This is called as <i>dirty-checking.</i></div><br /><script src="https://gist.github.com/atishaybaid/f8be6ffe587a79c158bf.js"></script>This version of $digest(),is not very useful,we will improve this basic version of $digest()<br />The real purpose of $digest is to call the watch function and compare their old values with the new value returned,and calling the listener if the values are different.Hence we improve the watch function as..<br /><br /><br /><script src="https://gist.github.com/atishaybaid/59f20fc812ab0185d944.js"></script>For each watcher,we compare its new return value with the old return value.so every time when a new watch is registered,its old value comes out to be undefined and hence every listener is called at-least once.Finally we set the last value of watcher,to the new return value so that we can compare it with the value returned next time.<br />We have now created the essence of angular scopes,attaching watches and iterating them &nbsp;using $digest.<br />&nbsp; There is one catch here,what if our watch function returns 'undefined'?,our current implementation will not call the listener.<br />for solving this problem we will provide watch with a initial value,a functions suits best for this purpouse,as it is never equal to anything other then itself.<br /><script src="https://gist.github.com/atishaybaid/46ca1195f0fb6b10310c.js"></script></div><br /><br /><br />Going forward our next use-case should be to trigger chained watches in the same digest cycle,as it may happen that a watch's listener may change the value which is being watched by the watcher which have already run in the same digest cycle,and hence it may not notice the change in the same digest pass.<br />So we need to modify digest in a way that it keeps on iterating until the watched value keeps changing.Doing multiple passes is the only way we can get changes applied for the watcher.<br />We rename &nbsp;our current version of digest as digestOnce,<br /><script src="https://gist.github.com/atishaybaid/8734305a09ae00572660.js"></script>we will call this function repeatedly, until all watches are clean.<br /><script src="https://gist.github.com/atishaybaid/87691d34caae155ceb7d.js"></script>This implementation &nbsp;may also result in a Unstable state,What happens if there are two watches looking at change made by each other?That will happen if their is a unstable state and will never stabilizes.<br />What we could do is to throw a exception,we set maximum limit to 10 and will throw a exception if that limit exceeds.Now our digest becomes<br /><script src="https://gist.github.com/atishaybaid/8a6a6011032136689b83.js"></script></div><br /><br /><br />We will now implement $eval and $apply function,<br /><b>$eval </b>&nbsp;is used to evaluate any code with the current scope,$eval takes a function as a argument returns the value which is being returned by the function,the importance of $eval comes when we implements directives<br /><script src="https://gist.github.com/atishaybaid/cee25f7d163e4e8ea149.js"></script> <br /><br /><br />we do'nt call $digest directly from our code,instead we use <b>$apply </b>which calls $digest for us.<br />but when do we need to call $apply?very rarely,because calling a $apply will cause $digest to run all the watches,but we call it when we want some change to get notified manually.here's our implementation of $apply,it evaluates the passed function using $eval and then calls $digest<br /><br /><script src="https://gist.github.com/atishaybaid/048835704db5644e9fb1.js"></script> <br />The &nbsp;complete working code of the project can be found <a href="https://github.com/atishaybaid/angularInternals" target="_blank">here</a>.Feel free to post any reviews or feedback.</div>